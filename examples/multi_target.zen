// Multi-target example showcasing @target annotations
import { http, fs } from "std";

type User = {
    id: string,
    name: string,
    email: string,
}

@target(wasm, native)
async func loadUsers() -> Result<User[], Error> {
    @target(wasm) {
        // Web version - fetch from API
        const response = await http.get("/api/users");
        if (response.status != 200) {
            throw Error(`HTTP Error: ${response.status}`);
        }
        return json.parse<User[]>(response.body);
    }
    
    @target(native) {
        // Desktop version - read from file
        const data = try fs.readFile("users.json") else {
            throw Error("Could not read users.json");
        };
        return json.parse<User[]>(data);
    }
}

@hotpatch  // Development only - allows hot-reloading
func processUser(user: User) -> string {
    // This function can be modified while the program is running in dev mode
    return `Processing user: ${user.name} (${user.email})`;
}

async func main() -> i32 {
    print("Loading users...");
    
    const users = await loadUsers() catch {
        NetworkError(msg) => {
            print(`Network error: ${msg}`);
            return 1;
        },
        FileError(msg) => {
            print(`File error: ${msg}`);
            return 1;
        },
        _ => {
            print("Unknown error occurred");
            return 1;
        },
    };
    
    print(`Loaded ${users.length} users`);
    
    for (user in users) {
        const result = processUser(user);
        print(result);
    }
    
    return 0;
}

type Error = {
    message: string,
}

type NetworkError = {
    message: string,
}

type FileError = {
    message: string,
}

func print(text: string) {
    // Runtime implementation
}